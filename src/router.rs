/// This module provides the `Router` struct, which is responsible for managing routes,
/// dispatching requests, and applying middleware in the Tako framework.
use std::sync::{Arc, RwLock};

use dashmap::DashMap;
use http::StatusCode;
use hyper::Method;

use crate::{
    body::TakoBody,
    extractors::params::PathParams,
    handler::{BoxHandler, Handler},
    middleware::Next,
    responder::Responder,
    route::Route,
    state::set_state,
    types::{BoxMiddleware, Request, Response},
};

#[cfg(feature = "plugins")]
use crate::plugins::TakoPlugin;

#[cfg(feature = "plugins")]
use std::sync::atomic::AtomicBool;

/// The `Router` struct is responsible for managing the application's routes and middleware.
/// It provides methods to define routes, apply middleware, and dispatch incoming requests.
///
/// # Example
///
/// ```rust
/// use tako::router::Router;
/// use http::Method;
///
/// let mut router = Router::new();
/// router.route(Method::GET, "/example", |req| async move {
///     // Handle the request
///     Ok(req)
/// });
/// ```
pub struct Router {
    routes: DashMap<(Method, String), Arc<Route>>,
    middlewares: RwLock<Vec<BoxMiddleware>>,
    #[cfg(feature = "plugins")]
    plugins: Vec<Box<dyn TakoPlugin>>,
    #[cfg(feature = "plugins")]
    plugins_initialized: AtomicBool,
}

impl Router {
    /// Creates a new, empty `Router`.
    ///
    /// # Returns
    ///
    /// A new instance of `Router` with no routes or middleware.
    pub fn new() -> Self {
        Self {
            routes: DashMap::default(),
            middlewares: RwLock::new(Vec::new()),
            #[cfg(feature = "plugins")]
            plugins: Vec::new(),
            #[cfg(feature = "plugins")]
            plugins_initialized: AtomicBool::new(false),
        }
    }

    /// Adds a new route to the router.
    ///
    /// # Arguments
    ///
    /// * `method` - The HTTP method for the route (e.g., GET, POST).
    /// * `path` - The path pattern for the route (e.g., "/example").
    /// * `handler` - The handler function to process requests matching this route.
    ///
    /// # Returns
    ///
    /// An `Arc` pointing to the created `Route`.
    ///
    /// # Example
    ///
    /// ```rust
    /// use tako::router::Router;
    /// use http::Method;
    ///
    /// let mut router = Router::new();
    /// router.route(Method::GET, "/example", |req| async move {
    ///     // Handle the request
    ///     Ok(req)
    /// });
    /// ```
    pub fn route<H>(&mut self, method: Method, path: &str, handler: H) -> Arc<Route>
    where
        H: Handler + Clone + 'static,
    {
        let route = Arc::new(Route::new(
            path.to_string(),
            method.clone(),
            BoxHandler::new(handler),
            None,
        ));
        self.routes
            .insert((method.clone(), path.to_owned()), route.clone());
        route
    }

    /// Adds a new route with Trailing Slash Redirection (TSR) enabled.
    ///
    /// TSR ensures that requests to paths with or without a trailing slash are redirected
    /// to the canonical version of the path.
    ///
    /// # Arguments
    ///
    /// * `method` - The HTTP method for the route (e.g., GET, POST).
    /// * `path` - The path pattern for the route (e.g., "/example").
    /// * `handler` - The handler function to process requests matching this route.
    ///
    /// # Returns
    ///
    /// An `Arc` pointing to the created `Route`.
    ///
    /// # Panics
    ///
    /// This method will panic if called with the root path ("/").
    pub fn route_with_tsr<H>(&mut self, method: Method, path: &str, handler: H) -> Arc<Route>
    where
        H: Handler + Clone + 'static,
    {
        if path == "/" {
            panic!("Cannot route with TSR for root path");
        }

        let route = Arc::new(Route::new(
            path.to_string(),
            method.clone(),
            BoxHandler::new(handler),
            Some(true),
        ));
        self.routes
            .insert((method.clone(), path.to_owned()), route.clone());
        route
    }

    /// Dispatches an incoming request to the appropriate route handler.
    ///
    /// This method matches the request's method and path against the defined routes.
    /// If a matching route is found, its handler is invoked. Middleware is applied
    /// in the order it was added.
    ///
    /// # Arguments
    ///
    /// * `req` - The incoming HTTP request.
    ///
    /// # Returns
    ///
    /// A `Response` generated by the matched route handler or middleware.
    ///
    /// If no matching route is found, a 404 response is returned. If TSR is enabled
    /// for a route, a 307 redirect response is returned for paths with or without
    /// a trailing slash.
    pub async fn dispatch(&self, mut req: Request) -> Response {
        let method = req.method();
        let path = req.uri().path();

        for route in self.routes.iter() {
            if &route.method != method {
                continue;
            }

            if let Some(params) = route.match_path(path) {
                if !params.is_empty() {
                    req.extensions_mut().insert(PathParams(params));
                }

                let g_mws = self.middlewares.read().unwrap().clone();
                let r_mws = route.middlewares.read().unwrap().clone();
                let mut chain = Vec::new();
                chain.extend(g_mws.into_iter());
                chain.extend(r_mws.into_iter());

                let next = Next {
                    middlewares: Arc::new(chain),
                    endpoint: Arc::new(route.handler.clone()),
                };
                return next.run(req).await;
            }
        }

        let tsr_path = if path.ends_with('/') {
            path.trim_end_matches('/').to_string()
        } else {
            format!("{}/", path)
        };

        for route in self.routes.iter() {
            if &route.method == method && route.tsr && route.match_path(&tsr_path).is_some() {
                return hyper::Response::builder()
                    .status(StatusCode::TEMPORARY_REDIRECT)
                    .header("Location", tsr_path)
                    .body(TakoBody::empty())
                    .unwrap();
            }
        }

        hyper::Response::builder()
            .status(StatusCode::NOT_FOUND)
            .body(TakoBody::empty())
            .unwrap()
    }

    /// Adds a global state value to the router.
    ///
    /// This method allows you to store shared state that can be accessed by handlers
    /// and middleware.
    ///
    /// # Arguments
    ///
    /// * `key` - A unique key to identify the state value.
    /// * `value` - The state value to store.
    ///
    /// # Example
    ///
    /// ```rust
    /// use tako::router::Router;
    ///
    /// let mut router = Router::new();
    /// router.state("config", "example_value".to_string());
    /// ```
    pub fn state<T: Clone + Send + Sync + 'static>(&mut self, key: &str, value: T) {
        set_state(key, value);
    }

    /// Adds a middleware function to the router.
    ///
    /// Middleware functions are executed in the order they are added, and they can
    /// modify or reject requests before they reach the route handler.
    ///
    /// # Arguments
    ///
    /// * `f` - A middleware function that takes a `Request` and returns a `Future`
    ///         resolving to either a modified `Request` or a `Response`.
    ///
    /// # Example
    ///
    /// ```rust
    /// use tako::router::Router;
    /// use anyhow::Result;
    ///
    /// let mut router = Router::new();
    /// router.middleware(|req| async move {
    ///     println!("Incoming request: {:?}", req);
    ///     Ok(req)
    /// });
    /// ```
    pub fn middleware<F, Fut, R>(&self, f: F) -> &Self
    where
        F: Fn(Request, Next) -> Fut + Clone + Send + Sync + 'static,
        Fut: std::future::Future<Output = R> + Send + 'static,
        R: Responder + Send + 'static,
    {
        let mw: BoxMiddleware = Arc::new(move |req, next| {
            let fut = f(req, next);
            Box::pin(async move { fut.await.into_response() })
        });

        self.middlewares.write().unwrap().push(mw);
        self
    }

    /// Adds a plugin to the router.
    ///
    /// Plugins extend the functionality of the router by providing additional features
    /// such as logging, metrics, or custom behavior.
    ///
    /// # Arguments
    ///
    /// * `plugin` - The plugin to add, which must implement the `TakoPlugin` trait.
    ///
    /// # Returns
    ///
    /// A mutable reference to the `Router` for method chaining.
    #[cfg(feature = "plugins")]
    pub fn plugin<P>(&mut self, plugin: P) -> &mut Self
    where
        P: TakoPlugin + Clone + Send + Sync + 'static,
    {
        self.plugins.push(Box::new(plugin));
        self
    }

    /// Retrieves all plugins added to the router.
    ///
    /// This method returns a vector of references to the plugins currently added to the router.
    ///
    /// # Returns
    ///
    /// A vector of references to the plugins.
    /// Retrieves all plugins added to the router.
    ///
    /// This method returns a vector of references to the plugins currently added to the router.
    ///
    /// # Returns
    ///
    /// A vector of references to the plugins.
    #[cfg(feature = "plugins")]
    pub(crate) fn plugins(&self) -> Vec<&dyn TakoPlugin> {
        self.plugins.iter().map(|plugin| plugin.as_ref()).collect()
    }

    #[cfg(feature = "plugins")]
    pub(crate) fn setup_plugins_once(&self) {
        use std::sync::atomic::Ordering;

        if !self.plugins_initialized.swap(true, Ordering::SeqCst) {
            for plugin in self.plugins() {
                let _ = plugin.setup(self);
            }
        }
    }

    /// Merges another `Router` into the current `Router`.
    ///
    /// This method combines the routes and middlewares of the provided `Router`
    /// into the current `Router`. Routes from the other `Router` are added to
    /// the current one, and its middlewares are prepended to the route-level
    /// middlewares of the merged routes.
    ///
    /// # Arguments
    ///
    /// * `other` - The `Router` instance to merge into the current `Router`.
    ///
    /// # Behavior
    ///
    /// - Routes from the `other` router are added to the current router.
    /// - Middlewares defined at the router level in the `other` router are
    ///   prepended to the route-level middlewares of the merged routes.
    ///
    /// # Example
    ///
    /// ```rust
    /// use tako::router::Router;
    /// use http::Method;
    ///
    /// let mut router1 = Router::new();
    /// router1.route(Method::GET, "/example1", |req| async move {
    ///     Ok(req)
    /// });
    ///
    /// let mut router2 = Router::new();
    /// router2.route(Method::POST, "/example2", |req| async move {
    ///     Ok(req)
    /// });
    ///
    /// router1.merge(router2);
    /// ```
    pub fn merge(&mut self, other: Router) {
        other.routes.iter_mut().for_each(|mut entry| {
            let (key, route) = entry.pair_mut();
            // add router level middlewares at the beginning of the middlewares on route level
            for mw in other.middlewares.read().unwrap().iter().rev() {
                route.middlewares.write().unwrap().push_front(mw.clone());
            }

            self.routes.insert(key.to_owned(), route.to_owned());
        });
    }
}
